Go without the Operating System

Bernerd Schaefer
Developer at thoughtbot
@bjschaefer
b@thoughtbot.com

* Without the Operating System?

* Conventional deployment

There's some physical *hardware* in a data-center (or closet).

We want to run *multiple*user*applications* on that hardware.

The *operating*system* allows our applications to safely interface with and share the hardware.

* Cloud Deployment

Works like conventional deployment, except multi-tenant.

A *hypervisor* allows *multiple*operating*systems* to safely interface with and share hardware.

The *operating*system* duplicates work, allowing user applications to share hardware that's already shared (or even virtualized).

* Operating systems do a lot

Operating systems do a lot more than manage hardware.

They provide a *general*purpose*computing*environment*. Shell scripting, Cron jobs, terminal sessions, POSIX.

They are built on established, understood tools and have years (or decades) of development and production time.

* Operating systems are large projects

Typical server deployments have can 500+ packages built from *100,000,000+* lines of source code.

The Linux Kernel alone is *15,000,000+* lines of code.

These strongly impact:

- Boot time
- Footprint
- Performance
- Security (see Heartbleed, Shellshock, ImageTragick)

* Without the Operating System

We can remove the operating system if we run user applications that interface directly with the hypervisor.

These hypervisor-aware applications are called *unikernels*.

Where operating systems are general purpose, unikernels are highly specialized.

They take a number of forms. Some are for OS research. Others target particular language runtimes, like Haskell and Erlang. And, of course, Go!

* AtmanOS

* AtmanOS

It allows you to cross-compile Go programs, just like for Linux and Windows, to run directly on the Xen hypervisor.

The compiled images can be deployed on Amazon EC2, Linode, Rackspace, and IBM SoftLayer.

There are a few pieces to AtmanOS:

- a microkernel implemented in Go (and a little assembly)
- a suite of system packages, for communicating with Xen, reading and writing network packets, etc.
- a port of Go's runtime and standard library

* Porting Go

: Go's runtime provides a number of hooks,
: in the form of stub methods,
: for porting the runtime to a new OS / arch.

* Memory Management

  func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer

  func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64)

  func sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64)

* Time

  func nanotime() int64

  func time_now() (sec int64, nsec int32)

* Locking Primitives

  func semacreate() uintptr

  func semasleep(ns int64) int32

  func semawakeup(mp *m)

* Processes

  func newosproc(mp *m, stk unsafe.Pointer)

  func osyield()

* sys_freebsd_amd64.s

  TEXT runtimeÂ·nanotime(SB), NOSPLIT, $32
          MOVL	$232, AX
          MOVQ	$4, DI		// CLOCK_MONOTONIC
          LEAQ	8(SP), SI
          SYSCALL
          MOVQ	8(SP), AX	// sec
          MOVQ	16(SP), DX	// nsec

          // sec is in AX, nsec in DX
          // return nsec in AX
          IMULQ	$1000000000, AX
          ADDQ	DX, AX
          MOVQ	AX, ret+0(FP)
          RET

: In most ports, the hooks are Assembly and Go wrappers
: around syscalls.

* mem_linux.go

  func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {
          mSysStatInc(sysStat, n)

          p := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)
          if uintptr(p) == _ENOMEM {
                  throw("runtime: out of memory")
          }
          if p != v {
                  throw("runtime: cannot map pages in arena address space")
          }
  }

: But Atman is different.

* runtime as a kernel

Functions not system calls

- Memory Manager
- Time
- Locks
- Process Scheduler
- Device Drivers

: It's like this for everything that it's responsible for

* Memory Management

  type atmanMemoryManager struct {}

  func (*atmanMemoryManager) allocPages(v unsafe.Pointer, n uint64) unsafe.Pointer
  func (*atmanMemoryManager) allocPage(page vaddr)
  func (*atmanMemoryManager) clearPage(pfn pfn)
  func (*atmanMemoryManager) physAllocPage() pfn
  func (*atmanMemoryManager) reserveHeapPages(n uint64) unsafe.Pointer
  func (*atmanMemoryManager) reservePFN() pfn

* CODE WALK

* 2k lines of Go

* 200 lines of assembly

* DEMO

* What's next?

Deploy to EC2 and Linode

: It turns out this is tricky, and difficult to test.
: I want to do this in a demo, but I couldn't get Amazon
: to recognize the disk image.
: It's also Linux only...
: Anyone have experience with pv-grub or building custom kernels for Amazon?

`pprof`

: We could profile app and OS together!

TCP/IP stack and `net`

: The largest subsystem in Atman, and the first which can live
: almost entirely outside of the runtime.
: Lots of room to explore Go-native approaches.

Filesystems?

: Maybe?
