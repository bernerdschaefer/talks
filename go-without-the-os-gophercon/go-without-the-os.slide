Go without the Operating System

Bernerd Schaefer
Developer at thoughtbot
@bjschaefer
b@thoughtbot.com

* Without the Operating System?

* Conventional deployment

There's some physical *hardware* in a data-center (or closet).

We want to run *multiple*user*applications* on that hardware.

The *operating*system* allows our applications to safely interface with and share the hardware.

* Cloud Deployment

Works like conventional deployment, except multi-tenant.

A *hypervisor* allows *multiple*operating*systems* to safely interface with and share hardware.

The *operating*system* duplicates work, allowing user applications to share hardware that's already shared (or even virtualized).

* Operating systems do a lot

Operating systems do a lot more than manage hardware.

They provide a *general*purpose*computing*environment*. Shell scripting, Cron jobs, terminal sessions, POSIX.

They are built on established, understood tools and have years (or decades) of development and production time.

* Operating systems are large projects

Typical server deployments have can 500+ packages built from *100,000,000+* lines of source code.

The Linux Kernel alone is *15,000,000+* lines of code.

These strongly impact:

- Boot time
- Footprint
- Performance
- Security (see Heartbleed, Shellshock, ImageTragick)

* Without the Operating System

We can remove the operating system if we run user applications that interface directly with the hypervisor.

These hypervisor-aware applications are called *unikernels*.

Where operating systems are general purpose, unikernels are highly specialized.

* AtmanOS

* Port of Go for Xen

: Lets you cross-compile unmodified Go programs, just like for Linux and Windows,
: to run direclty on Xen.

Xen is a Hypervisor

It runs a "Host OS" (Linux of BSD) which provides drivers and executes
priveledged code.

Hypercalls

: Exposes priveleged operations, like system calls

Shared memory

: Provides access to shared data, and drivers

- Amazon EC2
- Linode
- Rackspace
- IBM SoftLayer

* Porting Go

: Go's runtime provides a number of hooks,
: in the form of stub methods,
: for porting the runtime to a new OS / arch.

* Memory Management

  func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer

  func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64)

  func sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64)

* Time

  func nanotime() int64

  func time_now() (sec int64, nsec int32)

* Locking Primitives

  func semacreate() uintptr

  func semasleep(ns int64) int32

  func semawakeup(mp *m)

* Processes

  func newosproc(mp *m, stk unsafe.Pointer)

  func osyield()

* sys_freebsd_amd64.s

  TEXT runtimeÂ·nanotime(SB), NOSPLIT, $32
          MOVL	$232, AX
          MOVQ	$4, DI		// CLOCK_MONOTONIC
          LEAQ	8(SP), SI
          SYSCALL
          MOVQ	8(SP), AX	// sec
          MOVQ	16(SP), DX	// nsec

          // sec is in AX, nsec in DX
          // return nsec in AX
          IMULQ	$1000000000, AX
          ADDQ	DX, AX
          MOVQ	AX, ret+0(FP)
          RET

: In most ports, the hooks are Assembly and Go wrappers
: around syscalls.

* mem_linux.go

  func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {
          mSysStatInc(sysStat, n)

          p := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)
          if uintptr(p) == _ENOMEM {
                  throw("runtime: out of memory")
          }
          if p != v {
                  throw("runtime: cannot map pages in arena address space")
          }
  }

: But Atman is different.

* runtime as a kernel

Functions not system calls

- Memory Manager
- Time
- Locks
- Process Scheduler
- Device Drivers

: It's like this for everything that it's responsible for

* Memory Management

  type atmanMemoryManager struct {}

  func (*atmanMemoryManager) allocPages(v unsafe.Pointer, n uint64) unsafe.Pointer
  func (*atmanMemoryManager) allocPage(page vaddr)
  func (*atmanMemoryManager) clearPage(pfn pfn)
  func (*atmanMemoryManager) physAllocPage() pfn
  func (*atmanMemoryManager) reserveHeapPages(n uint64) unsafe.Pointer
  func (*atmanMemoryManager) reservePFN() pfn

* CODE WALK

* 2k lines of Go

* 200 lines of assembly

* DEMO

* What's next?

Deploy to EC2 and Linode

: It turns out this is tricky, and difficult to test.
: I want to do this in a demo, but I couldn't get Amazon
: to recognize the disk image.
: It's also Linux only...
: Anyone have experience with pv-grub or building custom kernels for Amazon?

`pprof`

: We could profile app and OS together!

TCP/IP stack and `net`

: The largest subsystem in Atman, and the first which can live
: almost entirely outside of the runtime.
: Lots of room to explore Go-native approaches.

Filesystems?

: Maybe?
